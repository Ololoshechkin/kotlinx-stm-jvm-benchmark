# kotlinx-stm-jvm-benchmark

Замеры производительности kotlinx-stm плагина для платформы JVM с использованием Scala STM в качестве бекенда.

Произведено сравнение с Scala STM без плагина.

Для запуска необходимо:

1. В отдельной папке сделать git clone https://github.com/JetBrains/kotlin.git
2. Перейти на ветку rr/vbr/stm_merged2
3. сделать ./gradlew clean dist install -PdeployVersion=1.6.9-test. 
Это займет некоторое время и необходимо для локальной установки фейковой версии Kotlin 1.6.9-test, 
а также STM плагина аналогичной версии.
4. В другой папке сделать git clone https://github.com/Ololoshechkin/kotlinx-stm.git
5. Перейти на ветку local. 
Данная ветка является непубликуемой на bintray, однако предназначена для локального тестирования с версией Kotlin 1.6.9-test.
6. Сделать ./gradlew clean build publishToMavenLocal.
Эта команда локально опубликует версию koltinx-stm-runtime, а также scala-stm-impl тестовой версии 0.0.1-test-3.
7. После этого можно использовать kotlinx-stm-benchmark. Для запуска можно в Idea выполнить задачу benchmark в файле build.gradle


Результаты:

STM Plugin:
1. double read: 6503526.260 ±(99.9%) 33004.190 ops/s [Average]
2. double write: 5202700.373 ±(99.9%) 53289.924 ops/s [Average]
3. simple function: 548319.245 ±(99.9%) 2254.626 ops/s [Average]
4. multi threaded contention: 9.598 ±(99.9%) 0.100 ops/s [Average]
5. two nested transactions: 1892539.009 ±(99.9%) 7823.189 ops/s [Average]
6. single read: 7965529.080 ±(99.9%) 66017.935 ops/s [Average]
7. single write: 4507011.903 ±(99.9%) 32758.257 ops/s [Average]
8. swap: 3226139.148 ±(99.9%) 25304.523 ops/s [Average]

Pure Scala STM:
1. double read: 9549927.228 ±(99.9%) 101850.026 ops/s [Average]
2. double write: 6191880.741 ±(99.9%) 45013.415 ops/s [Average]
3. simple function: 560629.588 ±(99.9%) 2362.423 ops/s [Average]
4. multi threaded contention: 9.597 ±(99.9%) 0.101 ops/s [Average]
5. two nested transactions: 3285119.887 ±(99.9%) 29106.736 ops/s [Average]
6. single read: 11960569.363 ±(99.9%) 183952.378 ops/s [Average]
7. single write: 6813931.789 ±(99.9%) 123218.229 ops/s [Average]
8. swap: 3970667.060 ±(99.9%) 22335.240 ops/s [Average]

Как видно из замеров производительности выше, в тестах на примитивные операции в одном потоке (все кроме multi threaded contention)
реализация Scala STM быстрее в 1.41838 раз или на 41.838%, что объясняется тем, что STM плагин оборачивает каждый из библиотечных
вызовов в обертку, что приводит к накладным расходам на лишнее обращение к памяти, что заметно в синтетических тестах, в которых
отсутствует многопоточное исполнение, а также каждая операция является примитивной.

Однако данный сценарий не является ожидаемым сценарием использования STM в JVM для backend-приложений. STM является механизмом
управления многопоточным доступом, следовательно ожидаемый сценарий использования -- это многопоточные приложения с конкурентным
доступом к данным. Тест номер 4 "multi threaded contention" (multiThreadedAccountBenchmark) представляет собой тестирование
STM в условиях 4-поточного обращения к банковскому сервису, обслуживающему 10 банковских аккаунтов. В условиях данного теста,
являющегося более приближенным к реальности, накладные расходы при использовании плагина не были заметны, т.к. +1 лишнее обращение к
памяти и +1 лишний объект являются незначительными факторами на фоне накладных расходов на работу самого STM в условии контеншена.
Для сравнения, плагин показал производительность 9.598 ± 0.100 ops/s, а чистая Scala STM -- 9.597 ± 0.101 ops/s. Эти отрезки можно 
считать полностью совпадающими, что дает право заключить, что в многопоточной среде использование плагина не сказывается на 
производительности.



